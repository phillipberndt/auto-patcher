#!/bin/bash

# Look after changelog for script/patch version info.

# PDroid created by svyat. Official PDroid thread is
# http://forum.xda-developers.com/showthread.php?t=1357056

# The Auto-Patcher created by pastime1971 and mateorod
# Thread and support for the Auto-Patcher can be found at
# http://forum.xda-developers.com/showthread.php?p=27589651#post27589651

# ChangeLog
# 2012.05.00. (v0.1)
# 2012.05.12. (v0.2)   allows user to specify a different version of patches
# 2012.05.13. (v0.3.0) force "patch -N", remove temp upon failure, generate log output
# 2012.05.13. (v0.3.1) revised the generation of updater-script (SGS2)
# 2012.05.15.          added AOSP patches
# 2012.05.15.          added crespo-aosp patches; device-specific patching if patch exists
# 2012.05.15.          remove restore.zip upon failure
# 2012.05.15. (v0.4.1) added CM7 (GB) patches
# 2012.05.18. (v0.4.2) added checking for tool commands
# 2012.05.21. (v0.4.3) apply device-specific patches only when it is specified
# 2012.05.26.            added task title to log
# 2012.05.31. (v0.4.4) CM9 patches updated, crespo-aosp added
# 2012.06.04. (v0.4.5) added checking tools and rom, added aroma installer support
#                        add patch outputs reroute
# 2012.06.15.          CM9 patches updated
# 2012.06.16. (v0.4.6) AOKP patches updated, patch versions restructured
# 2012.06.17. (v0.5.0) patcher script reorganized, removed build.prop
# 2012.06.17. (v0.6.0) auto patcher script for pdroid and v6 patches
# 2012.06.19. (v0.6.1) add patches for CM7.2 Final
# 2012.06.20. (v0.6.2) updated CM 7.2 patches
# 2012.06.23. (v0.6.3) fix symlinks
# 2012.06.26. (v0.6.4) added 0618 patches for cm7 nightlies; removed 0619 cm7.2 final
# 2012.06.27. (v0.6.5) added new CM9 patches (20120626)
# 2012.06.27. (v0.6.6) added CM7 nightly patches (20120625) (finally!)
# 2012.07.02. (v0.7.0) Redid AOSP/AOKP; add Windows support (using Cygwin). Thanks kobik77!
# 2012.07.06. (v0.7.1) updated CM9 patches (20120706)
# 2012.07.08. (v0.7.2) updated AOKP (20120707) and CM9 (20120708) pdroid patches
# 2012.07.11. (v1.0.0) reworked script works on Linux, Mac OSX, and Windows (on Cygwin); 
#                        added new ICS/JellyBean support for the new V6-Supercharger
# 2012.07.18. (v1.0.1) new CM7/CM9 Pdroid patches (20120718)
# 2012.07.23. (v1.0.2) updated CM9 patches (20120723)
# 2012.07.23. (v1.0.3) updated CM9 patches (20120724)
# 2012.08.06. (v1.5.0) updated smali/baksmali binaries to 1.33
# 2012.08.06.          Added Pdroid/V6supercharger support for CM10 Jellybean!
# 2012.08.06.          Improved PDroid stability and efficiency (Thanks CollegeDev)
# 2012.08.06. (v1.6.0) added aokp-jb patches for pdroid/v6supercharger, script update
# 2012.08.17. (v1.9.5) Added support for pdroid_addon, by CollegeDev.
#                       Added insecure boot.img mod
#                       Added support for aosp-jb (This needs testing, and may not be
#                         a wide patch due to large variation between AOSP roms.
#                        -Please report all experiences!
#                       Updated all v6supercharger patches w/new edits to ProcessList
#                       Major script overhaul in preparation for additional mods!
# 2012.08.20. (v1.9.6) Conditional support for Official cm10 and aokp-jb builds
# 2012.08.23. (v1.9.7) Final/confirmed pdroid support for Official CM10 and AOKP-JB
# 2012.09.04  (v1.9.8) Bundled cygwin-compatible tools (original was corrupt).
#                       For Cygwin, replaced h2b function with simple bash math
#                       conversion (req'd for compat w/ Cygwin tools).
# 2012.08.26. (v2.0.0) Added .apk patching
#                       Added 3G Dongle support for Nexus 7 (trevd)
#                       TabletUI support for Nexus 7 (maybe more)
#                       Google Voice support for Nexus 7
#                      mods are 3gdongle, tabletUI, voice, or nexus7suite (for all)
#                      Added provisional file copy menu to widen patching base
# 2012.09.11. (v2.0.1) Cygwin support fixes
# 2012.09.11. (v2.0.2) Bugfix for 3gdongle (all)
# 2012.09.16. (v2.1.0) Significant restructuring of core operations; added edit text file
#                       fix for "method-cap" errors in pdroid.
# 2012.09.20. (v2.1.1) Fix for Phone FC's; OSX support finalized; ContentResolver resolved
# 2012.09.28. (v2.1.2) Hotfix for failed pdroid patching. Logging improvements.
# 2012.10.07. (v2.1.5) Final pdroid support for CM7.2 Official Releases
#                       Added aosp-mod patches for pdroid patching of AOSP kangs
#                       Switched to Chainfire's (f)aapt for speed/space reasons
# 2012.10.13. (v2.1.6) New PDroid patches for aokp-jb and cm10 4.1.2
#                       Revert (f)aapt- temporary due to reported issues
# 2012.10.15. (v2.17) New (again) CM10 pdroid patches.
#                     Move files to be copied into $p/$R/$B
#                      -This required a bunch of file moving-report broken symlinks.
#                     Some error check on the old RIL delete functions (thanks bundrik)
# 2012.10.16. (v2.1.7.5) Fix FC on phone with CM10 pdroid patches
# 2012.10.19. (v2.1.9) Testing CM10 support for PDroid Extension by CollegeDev.
# 2012.10.22. (v2.2.0) aosp/aokp and cm10 support for pdroid extension by CollegeDev
#                       MAJOR reworking of patches and improved query. only 4 mod types:
#                       cm, aokp, aosp, and pa. See our OP for details.
# 2012.10.26. (v2.3.0) Final (LTS) version. Stable for now until upstream breaks any patches
#                       Thanks to KicknGuitar for the OSX testing!
# 2012.11.01. (v2.3.1) Fix for pdroid RIL deletion for older roms
#                       Better Build query logic and help messages
# 2012.11.02. (v2.3.5) Add Evervolv support for all mods- Thanks to new maintainer poncik!
#                       Fix method cap for pdroid/pd2.0 for AOKP and kangs
# 2012.11.06. (v2.4.0) Update pd2.0 patches to latest pd2.0 release- all except Evervolv
#                       add GsmService to smali.txt; improve rom probe
# 2012.11.08. (v2.4.2) Add Evervolv support for pd2.0; Device-specific scripts
#                       Will display error if using a mod on an inapplicable rom
# 2012.11.09. (v2.4.5) Error catch for random method issues, fix pd2.0 Evervolv and aosp-jb
# 2012.11.17. (v2.4.6) Fix pdroid for CM7. FINALLY!.
# 2012.11.17. (v2.4.7) Internal debugging improvements
# 2013.01.13. (v2.5.0) Added 'openpdroid' mod --Open-Source Pdroid framework
#                       BIG Improvements to help and error-catch. Try ./auto_patcher -h
# 2013.01.15. (v2.5.1) OpenPDroid support for Evervolv and ParanoidAndroid, hotfix for Mms 
# 2013.01.15. (v2.5.2) Fix for cygwin temp files (kobik), provisional telephony files added
# 2013.01.16. (v2.5.3) SlimRom support. Rearrange structure for ApG.
# 2013.01.23. (v2.5.4) Fix small bugs related to rearrange
# 2013.01.25. (v2.5.7) 4.2 TabletUI support [cm,aokp,aosp,Evervolv]
# 2013.01.28. (v2.5.8) Fix for ICS PDroid; small fixes/expansions
# 2013.02.01. (v2.6.0) OpenPdroid 1.0.1 patches (cm, aokp, aosp, evervolv and slimrom. no pa.
#                       Fixed TabletUI for Cm10.1- aosp to come. Removed most old patches.
# 2013.02.01. (v2.6.25) PA OpenPDroid 1.0.1 patches; AOSP TabletUI. removed opd all 1.0.0
# 2013.02.09. (v2.7.0) Add new AOKP, CM9, CM10,CM10.1 and PA (3.0) patches for OPD
# 2013.02.09. (v2.7.5) Add new AOKP, AOSP, CM10.1 and PA (3.0) patches for OPD (Andr. 4.2.2)
# 2013.02.17. (v2.7.9) 4.2.2 opd 4 evervolv; v6supercharger,3gdongle and all but tabletUI.
# 2013.02.20. (v2.8.0) New CM10.1 opd patches. Each BID can have own provisionals now.
# 2013.02.23. (v2.8.2) SlimRom 4.2.2 support (from karamelos), APK recompile safety net.
# 2013.03.01. (v2.8.3) PAC (.aosp-pac) 4.2.2 support (from AussieLambChops), apktool 1.5.2
# 2013.03.03. (v2.8.4) Remove settings.apk from tabUI, replace Mms.apk. Refactors.
# 2013.03.06. (v2.8.5) Bugfixes, mainly.
# 2013.03.17. (v2.8.6) Added 4.2.2 tabletUI test run for CM from Caldair.
# 2013.03.18. (v2.8.6.5) Hotfix from caldair for tabletUI, new SlimRom patches
# 2013.03.18. (v2.8.7) TabletUI support for 10 inch screens (caldair)
# 2013.03.25. (v2.8.8) Fix for Cygwin paths with spaces (from kobik77)
# 2013.04.06. (v2.9.0) Added new tabletUI patches for CM and 4.2 conflicts.
# 2013.04.10. (v2.9.1) Updated aokp openpdroid patches (0405) please report.
# 2013.04.18. (V2.9.2) Added AOSP and SlimROm TabletUI patches (credit: Caldair)
# 2013.04.18. (V2.9.3) Added missing framework2.jar opd aosp 4.1
# 2013.05.08. (v2.9.4) Updates to TabletUI (from Caldair)
# 2013.05.18. (v2.9.5) New AOKP openpdroid patches (0514)
# 2013.05.20. (v2.9.6) New CM and PAC-man (aosp) openpdroid patches.
# 2013.05.27. (v2.9.7) $INCREMENTAL patches for bugs/updates and GPS fix for opd (credits to phillipberndt)
# 2013.05.30. (v2.9.8) Improve apk handling: test fix disappearing apks. New opd: evervolv,slim
# 2013.06.18. (v2.9.83) Introduce auto-update for OSX and Linux...turn off by setting it false in .config
#                        Update PACman patches for OPD and update telephony for PA to silence errors
# 2013.06.18. (v2.9.84) Some environment trickery to speed up search/sort. Add WEBSITE for mods.
#                        Check updating. New AOKP OPD patches
# 2013.06.19. (v2.9.85) Fixes to auto-update. Added changelog.txt
# 2013.06.20. (v2.9.865) Various bugfixes, add color, obfuscate $PROVISIONALS.
# 2013.06.21. (v2.9.87) Added ALTERNATE patches feature- hopefully fixes PA telephony issues.
# 2013.06.22. (v2.9.875) New tabletUI patches, revert flawed CONFLICTS feature
# 2013.06.22. (v2.9.88) New CM opd patches
# 2013.06.28. (v2.9.89) revert baksmali changes for now (still needs work), add new PACman OPD 6/26
# 2013.07.02. (v2.9.91) Switch to SlimRom team's aapt and apktool for OSX+Windows (Need OSX builder!)
# 2013.07.07. (v2.9.92) New opd patches for Slim/PA; some fixes to tabletUi by Caldair
# 2013.07.17. (v2.9.927) Fix missing Mms (finally), support for CM Final, many bugfixes (conflicts, mod ordering, etc.)
# 2013.07.20. (v2.9.93) New OPD CM patches, many bugfixes
# 2013.07.20. (v2.9.935) New PA, AOKP patches. gitattribute. FIx PING for cygwin. (h/t: gcydtmkq)
# 2013.08.05. (v2.9.941) Bundle patchv2.6.1 for cygwin.
# 2013.08.07. (v3.0.0) Support for Android-4.3 (Opendproid only- CM and AOSP).
# 2013.08.09. (v3.0.1) Build date and patch date matching for multiple mods- all mods will now use best available match.
# 2013.08.12. (v3.0.2) OpD support for Evervolv, PACman and PA and CM10 returns
# 2013.08.26. (v3.1.0) The big switch to SMALI.patch instead of JAR.patch. It begins...
# 2013.08.30. (v3.1.1) Some debugging and add Carbon support
# 2013.09.04. (v3.1.4) Update context_editor- still struggling with some Cygwin line endings.
# 2013.09.05. (v3.1.5) Push the 3.1 branch to master...if your rom fails please upload rom and sources!
# 2013.09.09.          Fix INCREMENTAL patches, fix git log error breaking otherwise fine build


# SHELL PROGRAMMING NOTES:
# [ -s FILE ]
# [[ -n STRING ]] or [[ -z STRING ]]

VERSION="v3.1.53"
# PATCHES_VERSION needs to be incremented every time ANY changes occur to patches.
PATCHES_VERSION="20130912"
CURRENT_ANDROID="4.3.0"

# pass variables to children
set -a

# Set any environmental variables
LANG=C
CYGWIN=false

# unused for now...for experiments with "-s" flag and new patches made with it.
BAKSMALI_BINARY=baksmali.jar
SMALI_BINARY=smali.jar
declare -a MODS_LIST
declare -a PATCH_DATE_LIST

# Available ROMTYPES.
# ROMTYPES that are hidden can be forced on the command line. But they are best left
# blank to be  automatically parsed by our romprobe or by just entering the parent...usually AOSP.

#Non-obvious ROMTYPE legend
# @.aosp-slim: SlimRom             @.aosp-pac: PAC-man
# @.aosp-ever: Evervolv            @pa: ParanoidAndroid (official jellybean branch only for now)
declare -a AVAILABLE_ROMTYPES=('aokp' 'aosp' 'cm' 'pa' '.aosp-slim' '.aosp-pac' '.aosp-ever')

# Config file: For now hosting AUTO_UPDATE and PRODUCTION(currently unused). Not under version control.
if [ ! -f .config ]; then
     cp -a ap_scripts/config_template .config
fi
source .config

# Colorize and add text parameters
red=$((tput setaf 1) 2>/dev/null)              # red
grn=$((tput setaf 2) 2>/dev/null)              # green
cyan=$((tput setaf 6) 2>/dev/null)             # cyan
txtBold=$((tput bold) 2>/dev/null)             # Bold
txtReset=$((tput sgr0) 2>/dev/null)            # Reset

colorize () {
     # pass color and then reset
     echo -e $@${txtReset}
}

colorize_bold () {
     echo -e ${txtBold}$@${txtReset}
}

printusage_help () {
     PID="openpdroid,3gdongle" # default example
     brief_help
}

brief_help () {
     echo "    usage:     ./auto_patcher <ROM> <MODS>"
     echo "    example:   ./auto_patcher CM10.zip $PID"
     echo ""
     echo "Use ./auto_patcher -h for the help menu"
     echo ""
     printtask "  If your rom is not on the supported list and you want it added:"
     printtask "\t- Upload your log and a link to the rom's source code (mandatory)"
     printtask "\t   and be patient, please!"
     echo ""
     cleanup
     exit
}

usage_help () {
     PID=mods
     mods_display
     echo "Multiple MODS can be combined by separating them with a comma and NO SPACES!!!"
     echo ""
     echo "    usage:     ./auto_patcher <ROM> <MODS>"
     echo ""
     echo "    example:   ./auto_patcher CM10.zip openpdroid,3gdongle"
     echo ""
     echo "  You no longer need to enter a ROMTYPE...EVER! It will hurt, not help."
     echo ""
     usage_more_help
}

usage_more_help () {
     echo "* press 'q' to see available patches and then CTRL-c to quit the help menu *"
}

display_help () {
     cd patches
     echo ""
     echo "AVAILABLE PATCHES"
     echo ""
     echo "*******************************************************************"
     echo "Note: There are ONLY 4 ROMTYPES: [pa, cm, aokp, and aosp]"
     echo ""
     echo "   Specifying ROMTYPE is DEPRECATED as of Autopatcherv3.1.0"
     echo ""
     find -H *  \( -name aokp -o -name cm -o -name aosp -o -name pa -o -name all -o -name generic \) -prune | column -c 85 | more -d -7
     echo ""
     echo "*****************************************************************"
     echo "Specific auto_patcher help options"
     echo "    ./auto_patcher -h mods      Lists mods"
     echo "                   -h <MODNAME> Specific <MOD> info"
     echo "                   -h advanced  Advanced usage+lists all available patch dates"
     echo ""
     cleanup
     exit
}

romtype_help () {
     # From rom_error (bad romtype) and date_error (patch date w/o specifying romtype)
     echo ""
     echo "!!!There are only four supported ROMTYPES: 1) cm  2) aokp  3) aosp  4) pa"
     echo ""
     echo "Specifying a romtype is no longer needed for any mod and is DEPRECATED."
     echo -e "  Try w/o it first, okay?"
     cleanup
     brief_help
}

advanced_help () {
     echo ""
     echo "The Auto-Patcher Advanced Usage"
     echo "*********************************"
     echo ""
     echo "For those of you determined to try everything..."
     echo ""
     echo "  You can also try adding a patch date as a final argument."
     echo ""
     echo "      ./auto_patcher <ROM> <MOD> <ROMTYPE> <DATE>"
     echo ""
     echo "  Please note: There are only four ROMTYPES: {pa, aokp, aosp and cm}"
     echo "      and you should really not need this anymore."
     echo ""
     echo "Odds are good that if you have a problem, specifying a ROMTYPE or PATCHDATE won't fix it!"
     echo ""
     echo "The Auto-Patcher has a pretty great rom probe, specifying the date and romtype is"
     echo " deprecated...you don't need to, we promise."
     echo ""
}

cleanup () {
     [[ -n $ROOT ]] && \rm -rf "$ROOT"/tmp*
}

garbage () {
    unset GARBAGE
    GARBAGE=($(find $@ -name "*.orig")) && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
    GARBAGE=($(find $@ -name "*.rej"))  && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
}


print_error () {
     # General purpose error. Used for errors in main, as opposed to probe or set-up.
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     brief_help
}

smali_error () {
     # Smali binary error. Problem often goes away on second run.
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     if [[ $(grep 'method index is too large' "$LOG") != "" ]]; then
          printtask "!!! Problem with method cap !!!"
          printtask "... attempting fix ..."
          . patches/.common/framework.jar.sh 2>&1 > ${JAR}.log
          printtask "... rebuild framework.jar ..."
          java -Xmx512M -jar smali.jar -a $API tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
          [ -f tmp/${FILE}.out/classes.dex ] || print_error "Could not resolve method cap issue- please submit log"
     else
          printtask "!!! This error is generally due to an unknown bug in the smali binary!"
          echo "In our experience, it goes away if you run the patcher a second time."
          echo " Please run the Auto-Patcher with the same command once again."
          echo ""
          echo "If after the third attempt the same thing happens,"
          echo " please upload your logfile to our support thread!"
          echo ""
          cleanup
          exit
     fi
}

unknown_mod_error () {
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     cleanup
     printusage_help
}

mismatch_error () {
     # Function that exposes attempts to apply a mod to an upsupported Android version
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     cleanup
     brief_help
}

date_error () {
     # Remind users to include a romtype if they are going to specify a patch date
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     echo " !! Manually specifying a date is DEPRECATED and no longer necessary. But if you insist..."
     echo "      Please put a ROMTYPE before the patch date and run again!!"
     romtype_help
}

rom_error () {
     # For when an unsupported romtype is manually entered on the command-line
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     romtype_help
}

conflict_error () {
     # For conflicting packages
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     cleanup
     PID=mods
     mods_info
}

misspatch_error () {
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!! error: $@ "
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     printtask "!! The Auto-Patcher could not find its patches and/or tools!"
     echo ""
     echo "* Did you run ./batch.sh first?"
     echo ""
     echo "The patch_patches.tgz and patch_tools.tgz need to be in this directory,"
     echo "  one way or another..."
     echo ""
     cleanup
     brief_help
}

misstools_error () {
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!! error: $@ "
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "Your set-up is missing a dependency."
     echo "We require JDK, tar, patch and cpio."
     echo ""
     echo ""
     echo "Each distro is different"
     echo "but ensure you have them all installed and try again."
     echo ""
     cleanup
     brief_help
}

miss_git_error () {
     printtask "Updater: disabled"
     echo ""
     printtask "You will not be able to get automatic updates because we could not find 'git'."
     printtask "Find out how to install git for your system and that feature should work automatically"
     echo ""
}

printtask () {
    echo "" >> "$LOG"
    echo -e $@ | tee -a "$LOG"
}

print_to_log () {
     echo "$@" >> "$LOG"
}

copy_prepatched_provisional () {
     print_to_log "File for which patching failed:"
     print_to_log "---------------------------------------------"
     print_to_log ""
     print_to_log "${FAIL##*/}"
     print_to_log ""
     print_to_log "---------------------------------------------"
     print_to_log ""
     print_to_log "We are adding a pre-patched copy of those files."
     print_to_log ""
     print_to_log "Please only file a bug report if running the program gives you problems!!!"
     print_to_log "... replace $FAIL ..."
     \rm -rf tmp/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL}.orig tmp/${FILE}.out/smali/${FAIL}.rej
     \cp -av  "$PROVISIONAL" tmp/${FILE}.out/smali/${FAIL} >> "$LOG" 2>&1
     SID=(${SID[@]} $FAIL)
     print_to_log "... failed patch sucessfully resolved ..."
}

prep_alternate_patch () {
     # Use alt.patch, if exists. Increment in case there are multiple alternates.
     # DEPRECATED as of the upcoming 3.1.0
     mv -v $ALTERNATIVE_PATCH $PARB/${NAME}.patch >> "$LOG"
     ALT_PATCH_NUMBER=$(($ALT_PATCH_NUMBER + 1))

     # Get fresh files/variables + decompile again (use rm b/c privacy files wouldn't get overwritten)
     # TODO: test patch -R instead of re-decompiling. Should work.
     rm -rf tmp/${FILE}.out/smali
     java -jar baksmali.jar -b -a $API -o tmp/${FILE}.out/smali ${FILE} >> "$LOG" 2>> "$LOG"
     unset FAILS && unset SID
     current_jar=$(($current_jar - 1))
     break
}

no_network_access () {
     PING_CHECK "www.github.com" >> "$LOG" 2>&1 && NETWORK=true # second try and check github
     PING_CHECK "www.google.com" >> "$LOG" 2>&1 # test for internet in general
     if [[ "$NETWORK" == true ]]; then
          return
     else
          printtask "Check for update failed, probably because of no internet access."
          echo "The autopatcher will continue with current local version: $VERSION"
          NETWORK=false
          echo ""
          sleep 2
     fi
}

auto_update_error () {
     echo ""
     printtask "### Update failed ###"
     printtask ""
     printtask "It appears you may have made some changes that prevent automatic updating."
     echo ""
     printtask "You could run 'git reset --hard' to return the autopatcher to its original form"
     printtask " or set AUTO_UPDATE to false in the .config file to stop getting this message."
     echo ""
     printusage_help
}

backup_script () {
     printtask "... backing up auto_patcher to auto_patcher.bak ..."
     cp -av auto_patcher auto_patcher.bak >> "$LOG" #backup for user in case of changes
     echo ""
}

warn_of_overwrite () {
     # Only seen once, by users without ".git" directories
     # Only users who got program @ download page see this, all others (ApG included) use git
     echo "This is a one time set-up process that will overwrite all local changes!"
     echo "If this is not ok with you press ctrl-C and set AUTO_UPDATE to false in .config"
     echo ""
}

establish_repo() {
          printtask "### establishing the repo ###"
          echo "... please be patient, this should only be needed once ..."
          echo ""
          git clone https://github.com/mateor/auto-patcher >> "$LOG" || no_network_access
          if ($NETWORK); then
               mv -v auto-patcher/".git" . >> "$LOG"
               rm -rf auto-patcher
               git checkout -q master || auto_update_error
               git reset --hard 2>&1 >> "$LOG"
               echo ""
          fi
}

export_log_and_variables () {
     AUTO_PATCHER_OLD_VERSION=$VERSION
     AUTO_PATCHER_OLD_PATCHES_VERSION=$PATCHES_VERSION
     AUTO_PATCHER_WAS_UPDATED=true
     UPDATED_LOG="$PATCHES_VERSION".updated.log
     cp -a "$LOG" "$UPDATED_LOG"
     rm -f "$LOG"
}

print_changelog () {
     CHANGELOG="changelog.txt"
     echo "" > "$CHANGELOG"
     CURRENT_HEAD=$(git rev-parse HEAD)
     echo "Changelog from Autopatcher$AUTO_PATCHER_OLD_VERSION to Autopatcher$VERSION" >> "$CHANGELOG"
     echo "---------------------------------------------------------------------------" >> "$CHANGELOG"
     echo "" >> "$CHANGELOG"
     echo "    Get more info about any individual commit by entering 'git show \$NUMBER'" >> "$CHANGELOG"
     echo "" >> "$CHANGELOG"
     git log --pretty=oneline $ORIGINAL_HEAD...$CURRENT_HEAD >> changelog.txt
     printtask "... "$CHANGELOG" has been updated ..."
}

replace_updater () {

# Function for devices that use SDcard installs. Also to be tested for CM7
#  since CM7 seems to use an updater-script that wipes EMMC. Testing

     \rm $UPDATER_LOC/$UPDS 2>&1
     \cp patches/.common/$UPDATER_LOC/$UPDS $UPDATER_LOC >> "$LOG" 2>&1
     echo "run_program(\"/sbin/busybox\", \"umount\", \"/system\");" >> UPDATE.txt
     cat UPDATE.txt >> $UPDATER_LOC/$UPDS
     echo ""
     echo "New updater-script being used:" >> "$LOG"
     echo "-----------------------------" >> "$LOG"
     cat $UPDATER_LOC/$UPDS >> "$LOG"
}

abspath () {
     case $(uname -s) in
     CYGWIN*)
          echo $(cygpath -ua "$1") | sed 's:/$::g'
          ;;
     Darwin)
          #[[ $(echo $1 | awk '/^\//') == $1 ]] && echo "$1" || echo "$PWD/$1"
          [[ ${1:0:1} == "/" ]] && echo "$1" || echo "$PWD/$1"
          ;;
     Linux)
          echo $(readlink -f "$1")
          ;;
     *)
          if [[ ${1:0:1} == "/" ]]; then
               echo "$1"
          elif [[ ${1:0:2} == "./" ]]; then
               echo "$PWD/${1:2}"
          else
               echo "$PWD/$1"
          fi
          ;;
     esac
}

mods_display () {
     echo ""
     echo "The Auto-Patcher $VERSION"
     echo "*******************************"
     echo ""
     echo "The available mods are"
     echo "****************************************************"
     echo "*  pdroid   openpdroid  voice   v6supercharger     *"
     echo "*  voice    insecure    secure  external_internal  *"
     echo "*  tabletUI 3gdongle    pd2.0                      *"
     echo "****************************************************"
     echo ""
     echo "To find out more about any mod, simply enter:"
     echo "     ./auto_patcher -h <MODNAME>"
     echo ""
     cleanup
}

mods_info () {
     # Defaults
     DEPENDENCY="None"
     DEV="Unknown"
     CEILING=$CURRENT_ANDROID
     ROM_CONFLICTS=(None)
     UNKNOWN_MOD=false
     DEVICE_LIMIT="None"
     case $PID in
     mods)
          mods_display
          exit
          ;;
     auto*)
          echo ""
          echo "**************************************"
          echo "The Auto-Patcher ate a kitten once..."
          echo "**************************************"
          echo ""
          DEV="mateor and Caldair"
          WEBSITE="https://github.com/mateor/auto-patcher"
          printusage_help
          ;;
     advanced)
          cd patches/
          (advanced_help && find -H * -name 201*) | more -d
          echo ""
          brief_help
          ;;
     voice)
          FLOOR=4.0.0
          DESC="Use on wifi-only tablets to have the software register as 'voice-enabled'. Allows VOIP like Google Voice to function."
          DESC="bongostl's setup method can be seen at the link."
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=1823701"
          DEV="bongostl"
          ;;
     v6 | v6supercharger)
          FLOOR=4.0.0
          CEILING=4.3.0
          DESC="A memory-management tool. It requires smali edits for Android roms 4.0+. The Auto-Patcher applies all 50+ edits recommended by the dev."
          DEV="Zeppelinrox"
          DEPENDENCY="The V6 Supercharger Script. Get it at the link"
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=991276"

          PID="v6supercharger" # allows shorthand 'v6' to find patches.
          ;;
     pdroid)
          FLOOR=2.3.7
          CEILING=4.1.2
          DESC="Security Software that manages access to personal data w/o causing FC's. No longer under development."
          DESC1="Try the open-source expansion of this program, OpenPdroid."
          DESC2="(It's the 'openpdroid' mod within the Auto-Patcher)."
          DEV="Svyat"
          DEPENDENCY="The Pdroid app. You can get it at the link"
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=1923576"

          ;;
     pd2.0)
          FLOOR=4.1.2
          CEILING=4.1.2
          DESC="An expansion of the PDroid application/framework."
          DEV="CollegeDev"
          DEPENDENCY="The free PDroid2.0 app available at the link"
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=1923576"
          ;;
     openpdroid)
          FLOOR=4.1.2
          CEILING=4.3.0
          DESC="A fork of the open-source PDroid and Pdroid2.0 framework."
          DEV="CollegeDev/FFU5y/wbedard/mateorod/Community"
          DEPENDENCY="PDroidManager(opensource) or PDroid2.0(CollegeDev)"
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=1994860"
          if [[ $ANDR == "4.1" ]]; then
               # Still borked, perhaps never to be fixed. PDroid works, and we SHOULD output a helpful message.
               ROM_CONFLICTS=( pa cm )
          fi
          ;;
     opendroid)
          echo ""
          echo "No mod named 'opendroid'. You probably mean 'openpdroid'. Try again."
          PID="mods"
          mods_info
          ;;
     external_internal)
          FLOOR=2.3.3
          CEILING=4.1.2
          DESC="Swap internal and external storage."
          ;;
     insecure)
          FLOOR=2.3.3
          DESC="Make any boot.img insecure and allow remount as well as adb push/pull of system files. True root."
          ;;
     secure)
          FLOOR=2.3.3
          DESC="Make any boot.img secure."
          ;;
     3gdongle)
          FLOOR=4.1.0
          CEILING=4.3.0
          DESC="Allows 3gdongles to work on wifi tablets w/o 3rd party applications."
          DEV="trevd"
          DEPENDENCY="None, but read the troubleshooting guide at the link"
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=1798631"
          DEVICE_LIMIT=( grouper )
          if [[ $ANDR == "4.3" ]]; then
               # at least. Looks like CM merged this mod. Probably other roms have as well.
               ROM_CONFLICTS=( cm )
          fi
          ;;
     tabletUI)
          FLOOR=4.1.0
          CEILING=4.3.0
          if [[ $ANDR == "4.3" ]]; then
               ROM_CONFLICTS=(.aosp-slim .aosp-ever aokp pa)
          elif [[ $ANDR == "4.2" ]]; then
               ROM_CONFLICTS=(.aosp-ever aokp pa)
          else
               ROM_CONFLICTS=(pa .aosp-slim)
          fi
          DESC="Changes the user interface of Phones and Phablets to the popular Tablet UI."
          DEV="barmullio/Caldair"
          WEBSITE="http://forum.xda-developers.com/showthread.php?t=2154075"
          ;;
     *)
          UNKNOWN_MOD=true
          FLOOR=?????
          CEILING=?????
          DESC="??? Unknown modtype ??? Check your spelling or the mod list!"
          DESC1="    Try: \"./auto_patcher -h mods\""
     esac

     # strip decimals from android version (i.e. 2.3.7 becomes 237) so we can do math
     NVID=${VID//[.]/}
     NVID=${NVID:0:3}
     COMPATF=${FLOOR//[.]/}
     COMPATC=${CEILING//[.]/}
     if [[ ${#NVID} -lt 3 ]]; then
          NVID="$NVID"0
     fi
}

apk_copy () {
     if [ -f patches/$P/$A/$R/$B/$FILE ]; then
          mkdir apk_staging
          cd apk_staging
          # Move the certs and manifests from the ROM's apk into the prepatched copy
          jar -xvf ../"$FILE" META-INF AndroidManifest.xml >> "$LOG"
          jar -ufv ../patches/$P/$A/$R/$B/$FILE META-INF/CERT* AndroidManifest.xml >> "$LOG" 2>> "$LOG"
          cd ..
          \cp -av patches/$P/$A/$R/$B/$FILE $FILE >> "$LOG" 2>&1
          echo "... Patching $APK failed, but we have successfuly copied over a prepatched file ..."
          apk_was_copied=true
     else
          print_error "failed patching $APK!!!"
     fi
}

no_mod_selected_error () {
     echo ""
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     printtask "!!! error: $@"
     printtask "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
     echo ""
     printtask "You need to enter a MOD before you try and specify the ROMTYPE."
     printtask "Check the help menu for the list of available MODS"
     echo ""
     printusage_help
}

check_against_rom_types () {
     # this checks to see if the user has entered a ROMTYPE in the MOD spot and outputs advice if so.
     NUMBER_OF_AVAILABLE_ROMTYPES=${#AVAILABLE_ROMTYPES[@]}
     for ((i=0; i < $NUMBER_OF_AVAILABLE_ROMTYPES; i++)); do
          if [[ ${AVAILABLE_ROMTYPES[i]} == "$P" ]]; then
               no_mod_selected_error "\"$P\" is a ROMTYPE not a MOD"
          fi
     done
}

compat_check () {
     for G in ${PID[@]}; do
          mods_info
          if ($UNKNOWN_MOD); then
               check_against_rom_types
               unknown_mod_error "\"$G\" is not a valid mod. Check your spelling or the mod list!!!"
          elif [[ "$NVID" -lt "$COMPATF" ]]; then
               mismatch_error "Your Android $VID rom is too old! The minimum for $G is \n !!! Android $FLOOR!"
          elif [[ "$NVID" -gt "$COMPATC" ]]; then
               mismatch_error "Sorry, $G has not been made available for Android $VID yet!"
          fi
     done
}

rom_compat_check () {
     N=${#ROM_CONFLICTS[@]}
     for ((i=0; i < $N; i++)); do
          if [[ $RID == ${ROM_CONFLICTS[$i]} ]]; then
               rom_compat_error
          fi
     done
}

rom_compat_error () {
     print_error "$PID is incompatible with $RID!!!"
}

device_compat_check () {
     O=${#DEVICE_LIMIT[@]}
     for ((i=0; i < $O; i++)); do
          if [[ $DID == ${DEVICE_LIMIT[$i]} ]]; then
               DEVICE_MATCHED=true
          fi
     done
     if [[ ! "$DEVICE_MATCHED" == true ]]; then
          device_compat_error
     fi
}

device_compat_error () {
     print_error "$PID is not available for $DID!!! Supported devices: ${DEVICE_LIMIT[@]}"
}

extpath () {
     case $(uname -s) in
     CYGWIN*)
          echo $(cygpath -da "$1")
          ;;
     *)
          echo $(abspath "$1")
          ;;
     esac
}

#contains () { for e in "${@:2}"; do [[ "$e" = "$1" ]] && return 0; done; return 1; }

parse () { echo "${1%%_*}"; }

getbuildprop () {
     if [ -f system/build.prop ]; then
          result=($(grep $1 system/build.prop | tr -d '\r' | tr '=' ' '))
          echo "${result[1]}"
     else
          echo ""
     fi
}


aosp_mod_check() {
     jar -xvf "$ROMX" system/framework/framework2.jar >> "$LOG"
     if [ -s system/framework/framework2.jar ]; then
          ever_check
     else
          AOSP=aosp
     fi
     echo $AOSP
}

ever_check() {
     MID=$(getbuildprop ro.build.romversion)
     if [[ $MID == "Evervolv"* ]]; then
          AOSP=".aosp-ever"
     else
          MID=$(getbuildprop ro.build.display.id)
          if [[ "$MID" == "ev"* ]]; then
               AOSP=".aosp-ever"
          else
               pac_check
          fi
     fi
     echo $AOSP
}

pac_check() {
     MID=$(getbuildprop ro.build.romversion)
     if [[ "$MID" == "pac"* ]] || [[ "$MID" == "PAC"* ]]; then
          AOSP=".aosp-pac"
     else
          MID=$(getbuildprop ro.build.display.id)
     if [[ "$MID" == "pac"* ]] || [[ "$MID" == "PAC"* ]]; then
         AOSP=".aosp-pac"
          else
               slim_check
          fi
     fi
}

slim_check() {
     SLMID=$(getbuildprop ro.modversion)
     SLMMID=$(getbuildprop updateme.name)
     if [[ "$SLMMID" == "Slim"* ]] || [[ $SLMMID == "slim"* ]]; then
          AOSP=".aosp-slim"
     elif [[ "$SLMID" == "Slim"* ]] || [[ $SLMID == "slim"* ]]; then
          AOSP=".aosp-slim"
     else
          if [[ "$ANDR" == "4.1" ]]; then
               AOSP=.aosp-mod
          else
               rootbox_check
          fi
     fi
}

rootbox_check() {
     ROOTBOXAID=$(getbuildprop ro.rootbox.version)
     if [[ -n $ROOTBOXAID ]]; then
          AOSP=.aokp-root
     else
          AOSP="aosp"
     fi
}

pa_check() {
     CMID=$(getbuildprop ro.modversion)
     PAID=$(getbuildprop ro.pa.version)
     MID=$(getbuildprop ro.build.display.id)
     [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
     DID=$(getbuildprop ro.product.device)
     [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)
          if [[ -n $PAID ]]; then
               RID=pa
          else
               case $CMID in
               [Pp][Aa]*)
                    RID=pa;
                    ;;
               *)
                    RID=cm;
                    ;;
               esac
          fi
}

romtype_set () {
     case $RID in
     cm)
          ROMTYPE="cm"
          ;;
     aokp*)
          ROMTYPE="aokp"
          ;;
     pa)
          ROMTYPE="pa"
          ;;
     *)
          ROMTYPE="aosp"
          ;;
     esac
}

proberom () {
     VID=$(getbuildprop ro.build.version.release)
     if [ ${#VID} -lt 4 ]; then # in case of non-standard versioning in build.prop (defy!)
          ANDR=$VID
     else
          ANDR="${VID:0:3}" # Cut to 1 significant digit to cover specific range or release.
     fi
     if [ "$ANDR" == "2.3" ]; then
          FLAVR=gingerbread
          API=10
          RID=cm;
     elif [ "$ANDR" == "4.0" ]; then
          FLAVR=ics
          API=15
          MID=$(getbuildprop ro.rommanager.developerid)
          [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.modversion))
          DID=$(getbuildprop ro.product.device)
          [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

          case "$MID" in
          pa|cm9|cm|cyanogenmod*)
               RID=cm;
               ;;
          aokp|teamkang)
               RID=aokp;
               ;;
          aosp*)
               RID=aosp;
               ;;
          *)
               echo "!!! $MID is not supported yet, trying aosp !!!"
               RID=aosp
               ;;
          esac
     elif [ "$ANDR" == "4.1" ]; then
          FLAVR=jellybean
          API=16
          CMID=$(getbuildprop ro.cm.version)
               if [[ -n $CMID ]]; then
                    pa_check
               else
                    MID=$(getbuildprop ro.build.display.id)
                    [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
                    DID=$(getbuildprop ro.product.device)
                    [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)
                    case "$MID" in
                    cm10|cm*|cyanogenmod*)
                         RID=cm;
                         ;;
                    aokp*|teamkang)
                         RID=aokp;
                         ;;
                    pa*)
                         RID=pa;
                         ;;
                    ev*)
                         RID=".aosp-ever";
                         ;;
                    *)
                         RID=$(aosp_mod_check);
                         ;;
                    esac
               fi
     elif [ "$ANDR" == "4.2" ] || [ "$ANDR" == "4.3" ]; then
          FLAVR=jellybean
          [ "$ANDR" == "4.2" ] && API=17
          if [ "$ANDR" == "4.3" ]; then
               API=18
               BAKSMALI_BINARY="baksmali.jar"
               SMALI_BINARY="smali.jar"
          fi
          CMID=$(getbuildprop ro.cm.version)
          MID=$(getbuildprop ro.build.display.id)
          [[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
          DID=$(getbuildprop ro.product.device)
          [[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

               case "$MID" in
               cm*|cyanogenmod*)
                    RID=cm;
                    ;;
               aokp*|teamkang)
                    RID=aokp;
                    ;;
               [Pp][Aa]*)
                    if [[ "$MID" == "pac"* ]] || [[ "$MID" == "PAC"* ]]; then
                         RID=".aosp-pac"
                    else
                         RID=pa;
                    fi
                    ;;
               ev*|Ever*)
                    RID=".aosp-ever";
                    ;;
               carbon*)
                    RID=".aosp-carbon"
                    ;;
               *)
                    RID="$(ever_check)";
                    ;;
               esac
     else
          print_error "unknown ROM version $VID: generally means cannot find/read build.prop"
     fi
     # romtype_set allows hiding ".aosp-*" types from users while leaving them as options on CLI
     romtype_set
     echo "... result of ROM check: version= $VID ..."
}


# Advanced build date query
# This should set the patch date automatically.

build_query() {
UTC=$(getbuildprop ro.build.date.utc)

# Difference in how OS X and Linux/Cygwin handles 'date' utility
case $(uname -s) in
[Dd]arwin)
     BDID=$(date -r $UTC +%Y%m%d)
     print_to_log "#### Darwin Build Query used ####"
     ;;
*)
     BDID=$(date -d "1970-01-01 UTC $UTC seconds" +"%Y%m%d")
     print_to_log "#### Standard Build Query ####"
     ;;
esac

# If patch date is specified on CLI, use that patch date
if [ $# -gt 3 ]; then
     BID=${4//,/ };
     BDID=$BID
else
     case $ANDR in
     2.3)
          # CM7 roms do not have UTC time stamp- so no build query.
          BID=latest;
          echo "*** CM7 roms default to latest patches. If using an older rom ***"
          echo "*** specify patch date on command line. Use -h to see available patches ***"
          ;;
     *)
          PATCH_COUNTER=0
          for P in ${PID[@]}; do
               [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
               [ -d patches/$P/$A/"$RID" ] && R=$RID || R=generic
               [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
               PAR=patches/$P/$A/$R
               PARB=patches/$P/$A/$R/$B
               DATES=$(ls patches/$P/$A/"$R" | grep '201*')
               # Intialize variable - an upperbound to determine lowest in first loop.
               BID=20201231
                    # find earliest available patch date
                    for i in $DATES; do
                         if [[ $i -lt $BID ]]; then
                              BID=$i
                         fi
                    done
               # Check if earliest patches are from before build date. Else use earliest

                    # If rom is newer than earliest patch set, find best match
                    if [[ $(($BID-$BDID)) -lt 0 ]]; then
                         for g in $DATES; do
                              # use any patch that matches $UTC
                              if [[ $(($BDID-$g)) -eq 0 ]]; then
                                   BID=$g
                                   break
                              # Set highest $BID w/o going over $UTC
                              elif [[ $(($BDID-$g)) -gt 0 ]] && [[ $g -gt $BID ]]; then
                                   BID=$g
                              fi
                         done
                    fi
                    # Error catch if query fails.
                    [[ $BID == "20201231" ]] && BID=latest && echo "Build Query Failed!! Default to latest!" >> "$LOG"
                    if [[ -n "$BID_OVERRIDE" ]]; then
                         BID="$BID_OVERRIDE"
                    fi
                    MODS_LIST[$PATCH_COUNTER]=$P
                    PATCH_DATE_LIST[$PATCH_COUNTER]=$BID
                    PATCH_COUNTER=$(($PATCH_COUNTER + 1))
          done
          ;;
     esac
fi
}

proberil () {
     RIL=$(getbuildprop ro.telephony.ril_class)
     [[ -n $RIL ]] && printtask "... result of ROM check: RIL= $RIL"
}

rominfo () {
echo "# VER= $VERSION" >> "$LOG"
echo "# OS=  $OSTYPE ${BIT}bit" >> "$LOG"
echo "# VID= $VID" >> "$LOG"
echo "# PID= ${PID[@]}" >> "$LOG"
echo "# MID= $MID" >> "$LOG"
echo "# RID= $RID" >> "$LOG"
echo "# ANDR= $ANDR" >> "$LOG"
echo "# BDID= $BDID" >> "$LOG"
echo "# DID= $DID" >> "$LOG"
echo "# BID= $BID" >> "$LOG"

if [ -d ../".git" ]; then
     echo "" >> "$LOG"
     echo -n "Current HEAD: " >> "$LOG"
     git log --pretty=oneline HEAD^..HEAD 2>/dev/null >> "$LOG" || true
     echo "" >> "$LOG"
fi

}

context_editor (){
     # This manages a troublesome class for OpD, ContextImpl. We create a new floating subclass, with
     #   a different file name for different roms ($ContextImpl$45, or $46 or $41, etc).

     # Counts the number of ContextImpl patches in the decompiled stock jar. Easy enough.
     CONTEXT_FILES=(tmp/system/framework/framework.jar.out/smali/android/app/ContextImpl*)

     # NUMBER will become the OpD-added new subclass
     CONTEXT_NUMBER=$((${#CONTEXT_FILES[@]} - 3))
     print_to_log "Matching the created file: ContextImpl\$$CONTEXT_NUMBER"

     # Only returns patches that create new files- it only matches patches with zero subtracted lines
     CORRECT_CONTEXT_MATCH=( $(find patches/$P/$A/$PROBE_RESULTS -type f -name *ContextImpl* -and -name *"$CONTEXT_NUMBER"*) )
     for c in ${CONTEXT_MATCH[@]}; do
          CORRECT_CONTEXT_MATCH=( ${CORRECT_CONTEXT_MATCH[@]} $(grep -HL '^-    ' $c) )
     done

     # only proceed if match is found TODO change to check for non-zero
     if ( [[ ${#CORRECT_CONTEXT_MATCH[@]} -gt 0 ]] ); then
          for context_match in ${CORRECT_CONTEXT_MATCH[@]}; do
               # strips file name to return path
               POSSIBLE_CONTEXT_DIR=$(echo $context_match | sed 's|\(.*\)/.*|\1|')
               break
          done
     else
          print_error "No patch sets create the proper ContextImpl file. Please upload log!"
     fi

     # Remove the, unlikely but possibly, mismatched ContextImpl patches from all Queues
     FAILED_PATCH_QUEUE=( ${FAILED_PATCH_QUEUE[@]//*'ContextImpl'*} )
     PATCH_QUEUE=( ${PATCH_QUEUE[@]//*'ContextImpl'*} )

     # Add the proper ContextImpl patches to the PATCH_QUEUE
     print_to_log "There are ${#CORRECT_CONTEXT_MATCH[@]} Context match; Using: $POSSIBLE_CONTEXT_DIR"
     print_to_log ""
     CONTEXT_PATCHES=($POSSIBLE_CONTEXT_DIR/*ContextImpl*)
     for C in ${CONTEXT_PATCHES[@]}; do
          PATCH_QUEUE+=($C)
     done
}

patch_matcher () {
     # Parse the FAILED_PATCH into a FILE- consequence of switching to "patch" matching instead of file.
     FAILED_FILE=${FAILED_PATCH##*/}     # strip path from file
     MATCHED_FILE=${FAILED_FILE##*_}     # strip headers from file name (e.g.returns 'SipPhone.patch')

     unset POSSIBLE_MATCHES
     PREP_POSSIBLE_MATCHES=$( find patches/$P/$ANDR -name *"$MATCHED_FILE"* )

     # Test for empty and test for too large (100?)
     ( [ "${#PREP_POSSIBLE_MATCHES[@]}" = 0 ] || [[ "${#PREP_POSSIBLE_MATCHES[@]}" -gt 100 ]] ) && print_error "There are ${#PREP_POSSIBLE_MATCHES[@]} possible matches, that's a problem!"

     # filter out patches that create new files, a silent failure since skipping those patches is stdout
     for possible in ${PREP_POSSIBLE_MATCHES[@]}; do
          CHECKED_MATCHES=$(grep -Hl '^-    ' $possible)
          POSSIBLE_MATCHES=( ${POSSIBLE_MATCHES[@]} "$CHECKED_MATCHES" )
     done

     # MATCH_SUCCESS is solely used to provide a fail message to log. Is there another way?
     #    cannot use success of patch process, skipped patch is stderr but okay for us.
     MATCH_SUCCESS=false
     for p in ${POSSIBLE_MATCHES[@]}; do
          $PATCH_BINARY --dry-run -Nls -p$STRIP_LEVEL -d tmp/${FILE}.out < $p 2>&1 > MATCH.log
          if ( [[ $(grep FAILED MATCH.log) = "" ]] ); then
                    # This below is temporary debug logging.
                    print_to_log "Succesful match found! Swapping $p for $FAILED_PATCH!!"
                    PATCH_QUEUE=( ${PATCH_QUEUE[@]//$FAILED_PATCH} )
                    PATCH_QUEUE+=( "$p" )
                    FAILED_PATCH_QUEUE=( ${FAILED_PATCH_QUEUE[@]//$FAILED_PATCH} )
                    MATCH_SUCCESS=true
                    break
         fi
     done
     cat MATCH.log >> "$LOG" # for now...I have seen some stderr get hidden without this.
     [ $MATCH_SUCCESS == true ] || print_to_log "We did not find a working patch for $p...looking for other solutions!"                       
}

if [[ $1 == -h ]]; then
     if [ $# -gt 1 ]; then
          PID=$2
          mods_info
          echo ""
          echo "The Auto-Patcher $VERSION by Mateorod and Pastime1971"
          echo "*************************************************"
          echo ""
          echo "Mod Name:    $PID"
          echo ""
          echo "    $DESC"
          if [[ $DESC1 ]]; then # test to see is there is a second DESC line
               echo "    $DESC1"
          fi
          if [[ $DESC2 ]]; then
               echo -n "$DESC2"
          fi
          echo ""
          echo "Developer: $DEV"
          echo "Dependancies: $DEPENDENCY"
          if [[ $WEBSITE ]]; then
               echo "Website: $WEBSITE"
          fi
          echo ""
          echo "Works on ROMs from Android $FLOOR -> $CEILING"
          echo
          brief_help
          exit
     fi
fi

[[ $# -lt 1 || -z $1 ]] && PID="mods" && mods_info
[[ $1 == "-h" ]] && usage_help | less && display_help

echo ""
echo "The Auto-Patcher $VERSION"
# by pastime1971 and mateorod
if [[ -n "$AUTO_PATCHER_WAS_UPDATED" ]]; then
     echo "     (auto-updated from $AUTO_PATCHER_OLD_VERSION)"
     print_changelog
fi
echo ""

ROOT="$(abspath "$(dirname "$(abspath "$(type -p "$0")")")")"
TOOL="$ROOT/patch_tools.tgz"
PTCH="$ROOT/patch_patches.tgz"
cleanup

# set temporary directory
DATE=$(date +%Y%m%d%H%M%S)
TEMP="$ROOT/tmp$DATE"
TMP="$ROOT/tmp$DATE"
TMPDIR="$ROOT/tmp$DATE"
mkdir "$TEMP"
ROM=$(abspath "$1")
ROMX=$(extpath "$1")
ERR="$TEMP"/ERR

exec 2>> ${ERR}.log

PATCH_BINARY=patch
PINGCOUNT="-c1"

if [[ $OSTYPE == "cygwin" ]]; then
     CYGWIN=true
     EXE=".exe"
     PGFORM="0x"
     PINGCOUNT="-n 1"
     #PATCH_BINARY="./patch"
     AUTO_UPDATE=false # CYGWIN AUTO_UPDATE TESTERS COMMENT THIS LINE HERE!
fi

PING_CHECK() {
     case $(uname -s) in
     [Dd]arwin*)
          (ping "$PINGCOUNT" "$@")
          ;;
     *)
          (ping $@ $PINGCOUNT)
          ;;
     esac
}


LOG=$(abspath ./log$DATE.txt)
#echo $ROOT $TOOL $ROM $TEMP "$LOG"
echo "ROOT= $ROOT" >> "$LOG"
echo "TOOL= $TOOL" >> "$LOG"
echo "ROM=  $ROM" >> "$LOG"
echo "ROMX= $ROMX" >> "$LOG"


# Auto-Update                           # excluding ApG/cygwin for now until I talk with kobik.
# To turn off auto updating, set AUTO_UPDATE in .config to false


# Check for git
if [ $(which git) ]; then
     GIT=true
else
     miss_git_error "Missing \"git\" utility"
     GIT=false
fi

if [[ "$AUTO_UPDATE" == true ]] && [[ "$GIT" == true ]]; then
     PING_CHECK "www.github.com" > /dev/null 2>&1 && NETWORK=true || no_network_access
     if [[ "$NETWORK" == true ]]; then
          printtask "### checking for updates ###"

          # establish the repo if not already present- one time operation.
          if [ ! -d ".git" ]; then
               printtask "... initial setup to allow automatic updating ..."
               backup_script && warn_of_overwrite
               establish_repo && export_log_and_variables
               printtask "### rerunning script with latest version ###"
               $0 "$@"
               exit 0
          fi

          # Here is the regular update process
          git fetch origin 2>&1 >> "$LOG" || no_network_access
          if !("$NETWORK"); then
               printtask "Updater: not able to run auto_update."
          else
               COMMITS_BEHIND=$(git rev-list HEAD..origin/master --count)
               case "$COMMITS_BEHIND" in
               0)
                    printtask "Updater: Auto-Patcher is already up to date"
                    ;;
               *)
                    ORIGINAL_HEAD=$(git rev-parse HEAD)
                    printtask "... Updater: update found ..."
                    backup_script
                    printtask "... Updating Auto-Patcher ..."
                    git merge --no-edit origin/master 2>&1 >> "$LOG" || auto_update_error
                    export_log_and_variables
                    printtask "### updated, now rerunning script with latest version ###"
                    $0 "$@"
                    exit 0
                    ;;
               esac
               echo ""
          fi
     fi
fi

if ( [[ -n "$AUTO_PATCHER_WAS_UPDATED" ]] || [ -f *".updated.log" ] ); then
     ORIGINAL_PATCHES_VERSION=$( ls *.updated.log | sed -e 's/\.updated.log//' )
     if ( [[ $PATCHES_VERSION -gt $AUTO_PATCHER_OLD_PATCHES_VERSION ]] || [[ $PATCHES_VERSION -gt $ORIGINAL_PATCHES_VERSION ]] ); then
          echo "... integrating new patches ..."
          sh batch.sh >> /dev/null 2>> "$LOG"
     fi
fi

# If program was updated, merge the logs
if ( [[ -n "$AUTO_PATCHER_WAS_UPDATED" ]] || [ -f *".updated.log" ] ); then
     cat *".updated.log" >> "$LOG"
     rm -f *".updated.log"
fi

#remove old zips, if built under identical parameters.
\rm -f $RESTORE $UPDATE

CHK=$(getconf LONG_BIT) 
if [[ $CHK = "64" ]]; then
     BIT=64
else [[ $BIT = "32" ]];
     BIT=32
fi

printtask "### verify tools ###"

if [[ $CYGWIN == false ]];then
     which patch >> "$LOG" || misstools_error "Missing \"patch\" utility."
fi
which tar >> "$LOG" || misstools_error "Missing \"tar\" utility"
which jar >> "$LOG" || misstools_error "Missing \"Java Development Kit\" (JDK)"
which java >> "$LOG" || misstools_error "Missing \"Java Development Kit\" (JDK)"
which cpio >> "$LOG" || misstools_error "Missing \"cpio\" utility"
[ -f "$TOOL" ] || misspatch_error "patch_tool.tgz is missing"
[ -f "$PTCH" ] || misspatch_error "patch_patches.tgz is missing"
printtask "### verify ROM ###"
[ -f "$ROM" ] || print_error "Cannot find $1!! Make sure you have the location and name right"
echo "### running $0 $@" >> "$LOG"
cd "$TEMP"

PATH="$TEMP:$PATH"
export PATH
echo "PATH= $PATH" >> "$LOG"

printtask "### unzip patch tools ###"
tar xzf "$TOOL" > /dev/null || print_error "failed extracting tools !!!"

# Get OS specific tools
     case $(uname -s) in
     CYGWIN*)
          \mv cygwin/aapt.exe .
          \mv cygwin/patch.* .
          \mv cygwin/*.exe boot/
          \rm -rf cygwin # why? If you want to we can keep/add it to mac/linux, though.
          ;;
     [Dd]arwin)
          \mv mac/aapt .
          ;;
     [Ll]inux)
          \mv linux/aapt .
          ;;
     *)
          \mv linux/aapt .
          ;;
     esac
# Ensure aapt permissions - possibly to one day be expanded to all tools in a function.
chmod a+x aapt$EXE

printtask "### unzip patch patches ###"
tar xzf "$PTCH" > /dev/null || print_error "failed extracting patches !!!"

# we need build.prop for both RIL probing and ROM probing
jar -xvf "$ROMX" system/build.prop 2>> "$LOG" || print_error "failed extracting build.prop from $ROMX !!!"

# rom + ril type
proberil
printtask "### probe rom type ###"
proberom
PROBE_RESULTS=$RID

# rom type
if [ $# -gt 1 ]; then
     PIT=$2
     if [[ "$PIT" = "-h" ]]; then
          display_help
     fi
fi

if [ $# -gt 2 ]; then
     RID=$3        
     case "$RID" in
     cm*|cyanogenmod*)
          RID=cm;
          ;;
     aokp*|teamkang)
          RID=aokp;
          ;;
     pa*)
          RID=pa;
          ;;
    .aosp-ever)
          RID=".aosp-ever";
          ;;
    .aosp-slim)
          RID=".aosp-slim"
          ;;
    .aosp-pac)
          RID=".aosp-pac"
          ;;
     aosp*)
          case "ANDR" in
          4.1)
               RID=$(aosp_mod_check);
               ;;
          *)
               RID=$(ever_check)
               ;;
          esac
          ;;
     201*)
          date_error "You must specify ROMTYPE if designating a patch date!!"
          ;;
     *)
          rom_error "$RID is not a valid ROMTYPE!!"
          ;;
     esac

     # Most of this needs to go...it is misleading and adds unnecessary steps for users. Available to devs only.
     romtype_set
     echo "... Using $ROMTYPE patches ..."
else
     echo "... Using results of ROM check ..."
fi

# patch type
if [ $# -gt 1 ]; then
     PIL=${2//,/ } # If more than one mod, make string separated by spaces
else
     PIL="openpdroid"
     echo "No mods selected. Defaulting to openpdroid, since that's what you probably want..."
fi

# Ensure only 1 Pdroid mod at a time; PDroid first, so provisionals do not overwrite other mods...

PID=(${PIL// / })                      # turn string of requested mods into array
COPYPID=("${PID[@]}")                  # working copy to iterate over
MODS_NUMBER=${#COPYPID[@]}             # number of elements (mods)

if [[ $MODS_NUMBER > 1 ]]; then        # because if only one mod, not needed
INDEX=0
     for p in ${COPYPID[@]}; do
          # this first loop detects presence of any pdroid mod and sets it to be first applied (SPID[0])
          if [ "$p" = "pdroid" ] || [ "$p" = "pd2.0" ] ||[ "$p" = "openpdroid" ]; then
               SPID[0]=$p              #set pdroid first
               unset COPYPID["$INDEX"]
               break
          else
               INDEX=$((INDEX + 1))    # if (!pdroid), set as 1, 2...
          fi
     done
     for p in ${COPYPID[@]}; do
          # ensures they aren't applyingy more than one pdroid mod and slots in any remaining mods.
          if [ "$p" = "pdroid" ] || [ $p = "pd2.0" ] ||[ $p = "openpdroid" ]; then
               conflict_error "Those mods conflict! Only one pdroid mod at a time!"
          else
               i=${#SPID[@]}
               SPID[$i]=$p
               i+=1
          fi
     done
else
     SPID=("${COPYPID[@]}")
fi
# reset the mod list, with the pdroid-type mod applied first (for provisional use's sake)
PID=("${SPID[@]}")

# Check if selected mods are available for rom's Android version.
compat_check

# Make sure mod and rom don't conflict (e.g. pa and tabletUI)
for T in ${PID[@]}; do
     PID=$T                  # Set PID so mods_info function returns different values for each mod
     mods_info               # Populate variables for each PID
     if [[ ${ROM_CONFLICTS[@]} != "None" ]]; then
          rom_compat_check
     fi
     if [[ ${DEVICE_LIMIT[@]} != "None" ]]; then
          device_compat_check
     fi
done
# reset to original ordered list
PID=("${SPID[@]}")

# Build date
if [ $# -gt 3 ]; then # if a date is specified on command line...
     # Set date to match argument and ensure that patches with that date exist
     BID=$4
     [ -d patches/$PID/$ANDR/$RID/$BID ] || print_error  "No $PID patches for $RID on $BID!! Try the help menu!!"
     # Run build_query- this overrides the above but gets useful info
     build_query
     # Reset patch date to argument (basically undo the effects of the build_query call)
     BID=$4
     printtask "... $PID patch date set manually to: $BID ..."
     PATCH_DATE_LIST[0]=$BID
else
     build_query # if no date specified, use one from build_query
fi

# echo ROM info
rominfo

if [[ ( "$PID" == "-h" || "$RID" == "-h" || "$BID" == "-h" ) ]]; then
     #Although this placement may be perfect for romfilter. although it throws the scheme...
     display_help
fi
#Begin cycle

for P in ${PID[@]}; do
     [ -d patches/$P ] || print_error "$P is not available"
     [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
     [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
     [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest

     unset FILES
     [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
     [ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
     [ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
     [ -f patches/$P/$A/$R/$B/files.txt ] && FILES=$(cat patches/$P/$A/$R/$B/files.txt)
     for FILE in ${FILES[@]}; do
          case "$FILE" in
          +system/*)
               [[ ${CID[@]} =~ ${FILE:1} ]] && print_error "${FILE:1} is already being copied" || CID=(${CID[@]} ${FILE:1})
               ;;
          -system/*)
               [[ ${EID[@]} =~ ${FILE:1} ]] || EID=(${EID[@]} ${FILE:1})
               ;;
          system/*.jar)
               [[ ${JID[@]} =~ $FILE ]] || JID=(${JID[@]} $FILE)
               echo "set_perm(0, 0, 0644, \"/$FILE\");" >> UPDATE.txt
               ;;
          # added for the use-case of apktool failure
          @system/*apk) # apks to decompile with smali binaries instead of apktool
               [[ ${JID[@]} =~ ${FILE:1} ]] || JID=(${JID[@]} ${FILE:1})
               FORMATTED_FILE=${FILE:1}
               echo "set_perm(0, 0, 0644, \"/$FORMATTED_FILE\");" >> UPDATE.txt
               ;;
          system/*.apk)
               [[ ${AID[@]} =~ $FILE ]] || AID=(${AID[@]} $FILE)
               echo "set_perm(0, 0, 0644, \"/$FILE\");" >> UPDATE.txt
               # $APKID will have elements removed sometimes--$AID is the master list for the update.zip
               declare -a APKID=( "${AID[@]}" )
               ;;
          *.img)
               [[ ${IID[@]} =~ $FILE ]] || IID=(${IID[@]} $FILE)
               ;;
          system/*)
               [[ ${TID[@]} =~ $FILE ]] || TID=(${TID[@]} $FILE)
               ;;
          esac
     done
done
print_to_log "### DELETE FILES= ${EID[@]}"
print_to_log "### COPY FILES= ${CID[@]}"
print_to_log "### JAR FILES= ${JID[@]}"
print_to_log "### APK FILES= ${AID[@]}"
print_to_log "### IMG FILES= ${IID[@]}"
print_to_log "### TXT FILES= ${TID[@]}"

# extract system files
printtask "### unzip rom ###"
jar -xvf "$ROMX" ${JID[@]} ${AID[@]} ${IID[@]} ${TID[@]} 2>> "$LOG" || print_error "failed extracting ${JID[@]} ${AID[@]} ${IID[@]} from $ROMX !!!"


# Update/Restore.zip scripts and prep 
printtask "### create updater script ###"
UPDATER_LOC=META-INF/com/google/android
UPDS=updater-script
ROM_NAME=${ROMX##*/}
ROM_NAME=${ROM_NAME##*\\}
UPDATE="update-${PIL// /-}-$BDID.zip"
RESTORE="restore-from-${PIL// /-}-$BDID.zip"


jar -xvf "$ROMX" $UPDATER_LOC/$UPDS $UPDATER_LOC/update-binary
jar -xvf "$ROMX" $UPDATER_LOC/update-binary-installer 1> /dev/null 2> /dev/null

     # Determine Installer- Aroma or ClockworkMod
if [ -f $UPDATER_LOC/update-binary-installer ]; then
     printtask "... using Aroma installer ..."
     \mv $UPDATER_LOC/update-binary-installer $UPDATER_LOC/update-binary
else
     printtask "... using Clockworkmod installer ..."
fi

     # Create updater scripts
cat patches/.common/updater-message.txt >> $UPDS
cat $UPDATER_LOC/$UPDS | grep ^mount | grep "/system" | head -n 1 >> $UPDS
[ -s $UPDS ] || echo "run_program(\"/sbin/busybox\", \"mount\", \"/system\");" >> $UPDS
     # restore the original
for FILE in ${EID[@]}; do
     jar -xvf "$ROMX" $FILE 2> /dev/null || printtask "!!! warning $FILE cannot be restored !!!"
done
     # replace with the original or delete it
for FILE in ${CID[@]}; do
     jar -xvf "$ROMX" $FILE 2> /dev/null || echo "delete(\"/$FILE\");" >> $UPDS
done
echo "package_extract_dir(\"system\", \"/system\");" >> $UPDS
     # permission management for files that need specific perms
cat $UPDATER_LOC/$UPDS | grep set_perm | grep "/system" >> $UPDS
for P in ${PID[@]}; do
     if [ -s patches/$P/$A/set_perm.txt ]; then
          echo "...setting permissions..."
          cat patches/$P/$A/set_perm.txt >> $UPDS
     fi
done
cat $UPDATER_LOC/$UPDS | grep ^unmount | grep "/system" | head -n 1 >> $UPDS
[[ ${IID[@]} =~ boot.img ]] && cat $UPDATER_LOC/$UPDS | grep "boot.img" >> $UPDS
echo "ui_print(\"                                        .\");" >> $UPDS
echo "ui_print(\"                                            .\");" >> $UPDS
echo "ui_print(\"                                                done!\");" >> $UPDS
cat $UPDS > $UPDATER_LOC/$UPDS
echo "# generated $UPDS" >> "$LOG"
cat $UPDS >> "$LOG"

printtask "### create restore.zip ###"
jar -cvf tmp.zip ${JID[@]} ${AID[@]} ${IID[@]} META-INF > /dev/null 2>> "$LOG"
java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip signed.zip 2>> "$LOG"
\mv signed.zip $RESTORE
\rm -f tmp.zip


# Begin patching process

printtask "### decompile system files ###"
for FILE in ${JID[@]}; do
     JAR=${FILE##*/}
     printtask "... decompile $JAR ..."
     java -jar baksmali.jar -b -a $API -o tmp/${FILE}.out/smali ${FILE} >> "$LOG" 2>> "$LOG"
     if [ $FILE == "system/framework/framework.jar" ]; then
          printtask "... extract preloaded-classes ..."
          jar -xvf ${FILE} preloaded-classes >> "$LOG" 2>> "$LOG"
          \mv preloaded-classes tmp/${FILE}.out/
     fi
done

     # install framework-files for apktool
if [ ${#AID[@]} -gt 0 ]; then
     jar -xvf "$ROMX" system/framework/framework-res.apk >> "$LOG"
     printtask "... installing framework files ..."
     # have to redirect to /dev/null...oddly framework installation reported as stderr; bug in apktool (confirmed).
     java -jar apktool.jar if system/framework/framework-res.apk >> /dev/null 2>&1
     for FILE in ${AID[@]}; do
          APK=${FILE##*/}
          if [ -f $FILE ]; then
               printtask "... decompile $APK ..."
               java -jar apktool.jar d -f $FILE tmp/$FILE.out 2>> "$LOG"
          fi
     done
fi

     # Unpack image files {boot.img only so far...}
for FILE in ${IID[@]}; do
     printtask "### unpacking $FILE ###"
     case "$FILE" in
     boot.img)
          if [ -f boot.img ]; then
               cd boot
               ./unpackbootimg$EXE -i ../boot.img >> "$LOG" 2>> "$LOG"
               mkdir ramdisk
               cd ramdisk
               gzip -dc ../boot.img-ramdisk.gz | cpio -i >> "$LOG" 2>> "$LOG"
               cd ../../ 
          else
               print_error "A mod needs to patch boot.img! This rom does not contains boot.img."
          fi
          ;;
     *)
          print_error "cannot process $FILE"
          ;;
     esac
done

# apply system modification

for ((i=0; i < ${#PID[@]}; i++)); do
     P=${MODS_LIST[$i]}
     BID=${PATCH_DATE_LIST[$i]}
     [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
     [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
     [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
     PAR=patches/$P/$A/$R
     PARB=patches/$P/$A/$R/$B

     unset FILES COPY DELS JARS APKS IMGS TXTS
     [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
     [ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
     [ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
     [ -f patches/$P/$A/$R/$B/files.txt ] && FILES=$(cat patches/$P/$A/$R/$B/files.txt)
     for FILE in ${FILES[@]}; do
          case $FILE in
          +system/*)
               COPY=(${COPY[@]} ${FILE:1})
               ;;
          -system/*)
               DELS=(${DELS[@]} ${FILE:1})
               ;;
          system/*.jar)
               JARS=(${JARS[@]} $FILE)
               ;;
          @system/*)
               JARS=(${JARS[@]} ${FILE:1})
               ;;
          system/*.apk)
               APKS=(${APKS[@]} $FILE)
               ;;
          *.img)
               IMGS=(${IMGS[@]} $FILE)
               ;;
          system/*)
               TXTS=(${TXTS[@]} $FILE)
               ;;
          esac
     done

     [[ -n ${COPY[@]} ]] && printtask "### copy patch $P/$A ###"
     for FILE in ${COPY[@]}; do
          printtask "... copying $FILE ..."
          DEST=${FILE%/*}
          mkdir -p ./$DEST
          if [ -e patches/$P/$A/$R/$B/$FILE ]; then
               printtask "... overwriting $FILE from $P ..."
               \cp -av patches/$P/$A/$R/$B/$FILE ./$DEST >> "$LOG" 2>&1
          elif [ -e patches/$P/common/$FILE ]; then
               printtask "... overwriting $FILE from $P ..."
               print_to_log " ### SOMETHING WENT WRONG!! Could not find file-- using common. ###"
               \cp -av patches/$P/common/$FILE ./$DEST >> "$LOG" 2>&1
          else
               print_error "$FILE is missing in the patch. Please upload your logfile to the support thread!"
          fi
     done

     # unconditional smali copying- For particularly troublesome files TODO: remove. Not needed as of 3.1
     [ -f patches/$P/smali.txt ] && SMALI=$(cat patches/$P/smali.txt)
     [ -f patches/$P/$A/smali.txt ] && SMALI=$(cat patches/$P/$A/smali.txt)
     [ -f patches/$P/$A/$R/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/smali.txt)
     [ -f patches/$P/$A/$R/$B/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/$B/smali.txt)
     MOVE=${SMALI##*/}
     for SMALI in ${SMALI[@]}; do
           if [ -f patches/$P/$A/$R/$B/$SMALI ]; then
                printtask "... overwriting $MOVE ..."
                \cp -a patches/$P/$ANDR/$R/$B/$SMALI tmp/$SMALI >> "$LOG" 2>&1
# This lower area should be deprecated now...wait and see. Each BID has own link to provisionals now.
           elif [ -f patches/$P/$A/.provisionals/$SMALI ]; then
                printtask "... overwriting $MOVE ..."
                \cp -a patches/$P/$ANDR/.provisionals/$SMALI tmp/$SMALI >> "$LOG"
           fi
     done

     [[ -n ${DELS[@]} ]] && printtask "### delete patch $P/$A ###"
     for FILE in ${DELS[@]}; do
          printtask "... deleting $FILE ..."
          \rm -rf ./$FILE
     done
     [[ -n ${JARS[@]} ]] && printtask "### jar patch $P/$A ###"


     # Iterate through jars and patch. If fails, try other patches and prepatched provisionals.
     for (( current_jar=0; current_jar < ${#JARS[@]}; current_jar++)); do
          FILE=${JARS[$current_jar]}
          JAR=${FILE##*/}
          STRIP_LEVEL=1
          if [[ $FILE == *".jar" ]]; then # allows for *.apks to be decompiled by baksmali
               NAME=${JAR%.jar}
          else
          # check for abscense of any apks decompiled by baksmali ('@'* in files.txt).
               if [ ! -d "tmp/${FILE}.out" ] ; then
                    echo "No $JAR in your ROM. Not able to patch this file."
                    echo "## No $JAR in ROM ###" >> "$LOG"
                    declare -a JID=( ${JID[@]/$FILE/} )
                    break;
               fi
               NAME=$JAR # TODO: Maybe rename this, since it now encompases apks at times
          fi
          
          printtask "... apply $NAME.patch ..."

          declare -a PATCH_QUEUE=("patches/$P/$A/$R/$B/$NAME"_*patch)
          declare -a FAILED_PATCH_QUEUE
          # Sanity check for glob
          [[ "${PATCH_QUEUE[0]}" == "patches/$P/$A/$R/$B/$NAME"'_*patch' ]] && print_error "No matching patches!!"
          # check for INCREMENTAL patches- for hotfixes. To keep us from having to rebuild all patches for small bugs
          [ -f "patches/$P/$A/$R/$B/$NAME"-* ] && declare -a INCREMENTAL=( "patches/$P/$A/$R/$B/$NAME"-* )

          # Context Editor handles the ContextImpl class for OpD, which enables the end of user-space romtyping
          [[ "$NAME" == "framework" ]] && [[ "$P" == "openpdroid" ]] && context_editor

          # dry-run until we build a completely succesful patch queue. Add $k to FAILED upon failure
          rm -rf {JAR}.log # Needed since we append the patch output now
          for ((k=0;k < ${#PATCH_QUEUE[@]}; k++)) do
               $PATCH_BINARY --dry-run -Nls -p$STRIP_LEVEL -d tmp/${FILE}.out < ${PATCH_QUEUE[$k]} 2>&1 >> ${JAR}.log || FAILED_PATCH_QUEUE+=( ${PATCH_QUEUE[$k]} )
          done

          FAILS=($(grep FAILED ${JAR}.log | sed -e 's/.*smali\///' | sed -e 's/\.rej//'))

          # For each fail, try every available patch in the repo-- think of it as an 'exhaustive' patching      
          for FAILED_PATCH in ${FAILED_PATCH_QUEUE[@]}; do
              patch_matcher
          done

          # If no succesful patches are found- try PROVISIONALS- swap in files we KNOW can patch. USE SPARINGLY!!!
          if [[ -n ${FAILED_PATCH_QUEUE[@]} ]]; then
               for FAILED_PATCH in ${FAILED_PATCH_QUEUE[@]}; do

                    # Mostly unartful workarounds so we can manipulate either the patch in FAIL or the FILE
                    FAILED_FILE=${FAILED_PATCH##*/}            #strip path from file
                    MATCHED_FILE=${FAILED_FILE##*_}            #strip headers from file name

                    # MATCH_PATTERN includes period (e.g. 'FILE.') to avoid globbing extra subclasses (e.g.FILE$2)
                    MATCH_PATTERN=${MATCHED_FILE%patch}

                    for ITEM in ${FAILS[@]}; do
                         [[ "$ITEM" =~ "${MATCH_PATTERN}" ]] && FAIL=$ITEM && break
                    done

                    PROVISIONAL="patches/$P/$ANDR/.provisionals/${FILE}.out/smali/${FAIL}"
                    if [ ! -f "$PROVISIONAL" ]; then
                         print_error $MATCH_PATTERN"patch in $JAR cannot be remedied"
                    else
                         print_to_log "!!! patch error for $FAIL !!!"
                         [[ ${SID[@]} =~ $MATCHED_FILE ]] && print_error "$MATCHED_FILE was already replaced before"
                         copy_prepatched_provisional
                         patch_matcher
                    fi
               done
          fi
          rm -rf ${JAR}.log # needs to be cleared

          # Actual application of patches occurs here!
          for ((k=0;k < ${#PATCH_QUEUE[@]}; k++)) do
               print_to_log " ...applying ${PATCH_QUEUE[$k]} ..."
               $PATCH_BINARY -Nls -p$STRIP_LEVEL -d tmp/${FILE}.out < ${PATCH_QUEUE[$k]} >> ${JAR}.log 2>&1
          done
          # Incremental--use patch_matcher? (how, b/c dry-run...should INCREMENTAL be optional or fail-possible?
          for ((k=0;k < ${#INCREMENTAL[@]}; k++)) do
               print_to_log " ...applying ${INCREMENTAL[$k]} ..."
               $PATCH_BINARY -Nls -p$STRIP_LEVEL -d tmp/${FILE}.out < ${INCREMENTAL[$k]} >> ${JAR}.log 2>&1
          done
          [[ $(grep FAILED ${JAR}.log) != "" ]] && cat ${JAR}.log >> "$LOG" && print_error "failed $NAME.patch"
          cat ${JAR}.log >> "$LOG" # debug
          garbage tmp/${FILE}.out

     # run special $JAR.sh scripts if any JAR needs special attention 
          if [ -f patches/$P/$A/$R/$B/${JAR}.sh ]; then
               printtask "... apply $JAR.sh ..."
               . patches/$P/$A/$R/$B/${JAR}.sh 2>&1 > ${JAR}.log
               cat ${JAR}.log | tee -a "$LOG"
          fi
     done

     [[ -n ${APKS[@]} ]] && printtask "### apk patch $P/$A ###"
     for FILE in ${APKS[@]}; do
          APK=${FILE##*/}
          STRIP_LEVEL=2

          if [ -d "tmp/${FILE}.out" ] ; then
               declare -a PATCH_QUEUE=("patches/$P/$A/$R/$B/$APK"_*patch)
               # Sanity check for glob
               [[ "${PATCH_QUEUE[0]}" == "patches/$P/$A/$R/$B/$APK"'_*patch' ]] && print_error "No matching patches!!"
               unset FAILED_PATCH_QUEUE
               for ((k=0;k < ${#PATCH_QUEUE[@]}; k++)) do
                    # dry-run until we build a completely succesful patch queue. Add $k to FAILED upon failure
                    $PATCH_BINARY --dry-run -Nls -p$STRIP_LEVEL -d tmp/${FILE}.out < ${PATCH_QUEUE[$k]} 2>&1 >> ${APK}.log || FAILED_PATCH_QUEUE+=( ${PATCH_QUEUE[$k]} )
               done
               for FAILED_PATCH in ${FAILED_PATCH_QUEUE[@]}; do
                    patch_matcher
               done

               # Actual patching done here
               printtask "... apply $APK.patch ..."
               for ((k=0;k < ${#PATCH_QUEUE[@]}; k++)) do
                    print_to_log " ...applying ${PATCH_QUEUE[$k]} ..."
                    $PATCH_BINARY -Nls -p$STRIP_LEVEL -d tmp/${FILE}.out < ${PATCH_QUEUE[$k]} >> ${APK}.log 2>&1
               done
               cat ${APK}.log >> "$LOG"

               if [[ $(grep FAILED ${APK}.log) != "" ]]; then
                    apk_copy
                    declare -a APKID=( ${APKID[@]/$FILE/} )
               fi
               garbage tmp/${FILE}.out
          else
               # For the moment, we allow APKs to be skipped (e.g. Mms.apk for Wifi tablets)
               echo "No $APK in your ROM. Not able to patch this file."
               echo "## No $APK in ROM ###" >> "$LOG"
          fi
     done

     [[ -n ${IMGS[@]} ]] && printtask "### img patch $P/$A ###"
     for FILE in ${IMGS[@]}; do
          IMG=${FILE##*/}
          STRIP_LEVEL=1
          printtask "... applying $IMG.patch ..."
          $PATCH_BINARY -Nls -p$STRIP_LEVEL -d boot/ramdisk < $PARB/${IMG}.patch >> "$LOG" || print_error "failed patching $FILE"
     done

# Text Editing Functions --this can really do just about anything. Needs a working restore!
     [[ -n ${TXTS[@]} ]] && printtask "### text patch $P/$A ###"
     for FILE in ${TXTS[@]}; do
          TXT=${FILE##*/}
          STRIP_LEVEL=2
          if [[ -f $PARB/${TXT}.patch ]]; then
               printtask "... apply $TXT.patch ..."
               $PATCH_BINARY -Nls -p$STRIP_LEVEL -d system/ < $PARB/${TXT}.patch 2>&1 > ${TXT}.log 
               #cat ${TXT}.log | tee -a "$LOG"
               [[ $(grep FAILED ${TXT}.log) != "" ]] && print_error "failed $TXT.patch"
          fi
          if [[ -f $PAR/${TXT}.awk ]]; then
               printtask "... apply $TXT.awk ..."
               awk -f $PAR/${TXT}.awk $FILE > text || print_error "failed $TXT.awk"
               mv text $FILE
          fi
          if [[ -f $PAR/${TXT}.sed ]]; then
               printtask "... apply $TXT.sed ..."
               sed -f $PAR/${TXT}.sed $FILE > text || print_error "failed $TXT.sed"
               mv text $FILE
          fi
          if [[ -f $PAR/${TXT}.sh ]]; then
               printtask "... apply $TXT.sh ..."
               . $PAR/${TXT}.sh 2>&1 >> ${TXT}.log || print_error "failed $TXT.sh"
          fi
          garbage system/
     done
done

     # Device specific scripts- Placement is up-for-review
if [ -f patches/.devices/$DID/$DID.sh ]; then
     . patches/.devices/$DID/$DID.sh
fi

     # Replace updater-script for CM7- it formats system -Testing
if [ "$ANDR" == "gingerbread" ]; then
     replace_updater
fi

# Rebuilding system files

[[ -n ${JID[@]} ]] && printtask "### rebuild jar ###"
for FILE in ${JID[@]}; do
     JAR=${FILE##*/}
     printtask "... rebuild $JAR ..."
     java -Xmx512M -jar smali.jar -a $API tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
     [ -f tmp/${FILE}.out/classes.dex ] || smali_error "failed compiling $JAR !!!"
     jar -ufv ${FILE} -C tmp/${FILE}.out/ classes.dex >> "$LOG" 2>> "$LOG"
     if [ $FILE == "system/framework/framework.jar" ]; then
          jar -ufv ${FILE} -C tmp/${FILE}.out/ preloaded-classes >> "$LOG" 2>> "$LOG"
     fi
done

[[ -n ${APKID[@]} ]] && printtask "### rebuild apk ###"
for FILE in ${APKID[@]}; do
     APK=${FILE##*/}
     if [ -d tmp/${FILE}.out ]; then
          apk_was_copied=false
          printtask "... rebuild $APK ..."
          java -jar apktool.jar b tmp/${FILE}.out >> "$LOG" 2>> "$LOG" || apk_copy
          if !("$apk_was_copied"); then
               jar -uvf $FILE -C tmp/${FILE}.out/build/apk/ . > /dev/null 2>> "$LOG"
          fi
     fi
done

[[ -n ${IID[@]} ]] && printtask "### rebuild img ###"
for FILE in ${IID[@]}; do
     printtask "### rebuild $FILE ###"
     case $FILE in
     boot.img)
          # Rebuilding boot.img
          cd boot
          printtask "... rebuilding ramdisk ..."
          ./mkbootfs$EXE ./ramdisk | gzip > ramdisk-new.gz
          printtask "... composing boot.img ..."
          BASE=$(cat boot.img-base)
          # hex to decimal in cygwin prefixing "0x" w/ C arithmetic
          PGSIZE=$((${PGFORM}$(cat boot.img-pagesize)))
          CMDLINE=$(cat boot.img-cmdline)
          echo "cmdline = no_console_suspend=1 console=null $CMDLINE" >> "$LOG"
          echo "pagesize = $PGSIZE" >> "$LOG"
          echo "base = $BASE" >> "$LOG"
          printtask "... rebuilding boot.img ..."
          ./mkbootimg$EXE --kernel boot.img-zImage --ramdisk ramdisk-new.gz --cmdline "no_console_suspend=1 console=null $CMDLINE" --base "$BASE" --pagesize "$PGSIZE" -o ../boot.img || print_error "failed building boot.img"
          cd ..
          ;;
     *)
          print_error "cannot process $FILE"
          ;;
     esac
done

# Check ERR.log and return failure if there is any unhandled error.
cat ${ERR}.log
if ( [ -s ${ERR}.log ] ); then
     print_to_log "Unhandled error!" && cat ${ERR}.log >> "$LOG"
     print_error "There was an unhandled error! Please submit your log!"
fi

printtask "### create $UPDATE ###"
jar -cfv tmp.zip ${IID[@]} ${JID[@]} ${AID[@]} ${CID[@]} ${TID[@]} META-INF >> "$LOG" 2>> "$LOG"
java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip $UPDATE 2>> "$LOG"

\mv $RESTORE $UPDATE ..
printtask "### finished ###"
printtask ""
printtask "$(colorize_bold ${red}Congratulations), the patching was $(colorize_bold ${red}successful)."
printtask "Any errors you may have seen were succesfully handled!"
printtask ""
printtask "!!! Only file a bug report if the software is $(colorize_bold ${grn}not) behaving as expected !!!"
printtask ""
echo "to install patched files, flash:"
printtask "--- $(colorize_bold ${grn}$UPDATE)"
echo ""
printtask "to restore original system, flash:"
printtask "--- $(colorize_bold ${grn}$RESTORE)"
echo ""

     # add announcement- optional.
for P in ${PID[@]}; do
     [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
     [ -d patches/$P/$A/$RID ] && R=$RID || R=generic
     [ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
     if [ -f patches/$P/$A/$R/$B/README.txt ]; then
          cat patches/$P/$A/$R/$B/README.txt
     elif [ -f patches/$P/$A/$R/README.txt ]; then
          cat patches/$P/$A/$R/README.txt
     elif [ -f patches/$P/$A/README.txt ]; then
          cat patches/$P/$A/README.txt
     fi
done

cd ..
\rm -rf "$TEMP"
